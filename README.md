## 객체 지향 설계 원칙 SOLID
- **Single responsibility principle(SRP 단일 책임 원칙)**
	+ 변경이 있을 때 파급 효과가 최소화되어야 한다.
- **Open/closed principle(OCP 개방-폐쇄 원칙)**
	+ 소프트웨어 요소가 확장에는 열려 있으나, 변경에는 닫혀 있어야 한다.
	+ 사실 상 불가능한데, 스프링이 해결해준다.
	+ *자동차에 AI 기능 탑재 등을 추가 기능으로 구현했다면, 기존 코드에 추가만 있을 뿐, 수정은 없어야 한다.*
- **Liskov substitution principle(LSP 리스코프 치환 원칙)**
	+ 인터페이스 구현체를 믿고 사용하려면, 하위 클래스는 인터페이스 규약을 다 지켜야 한다.
	+ *엑셀 밟으면 전진해야 하는 규약이 있는데, 후진을 하면 안 된다.*
- **Interface segregation principle(ISP 인터페이스 분리 원칙)**
	+ 범용 인터페이스 하나보다 특정 클라이언트를 위한 인터체이스 여러 개가 낫다.
	+ 인터페이스가 명확해지고 대체 가능성이 높아진다.
	+ *자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스*
- **Dependency inversion principle(DIP 의존관계 역전 원칙)**
	+ 역할에 의존해야 한다. 구현 클래스에 의존하지 말고, 인터페이스에 의존해라.
	+ 서비스 클라이언트가 구현 클래스를 직접 선택하면 안 된다.
	+ *운전자는 엑셀을 밟으면 앞으로 간다는 것만 고려. 차종별 엑셀 구현체는 생각할 필요 없다.*



## interface

이상적으로는 모든 설계에 인터페이스를 구현하는 게 좋다.

- 아직 db 등 하부 구현 기술들에 대한 선택을 최대한 미룰 수 있다.
- 기획의 세부 사항이 정리되지 않아도(할인율 등) 개발을 진행할 수 있다.

하지만 비용이 발생.

- 서비스 코드만 보면 인터페이스만 보이기 때문에(추상화) 개발자가 코드를 다시 뜯어봐야 한다.
- 기능 확장 가능성이 없다면, 구체 클래스를 직접 사용하고 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.
- 이게 좋은 개발자, 좋은 아키텍트!

## IoC(Inversion of Control 제어의 역전)

- AppConfig를 통해 구현 객체는 자신의 로직을 실행하는 역할만 담당한다.
- 즉, 제어의 흐름은 AppConfig에 의해 결정된다.
- 프로그램의 제어 흐름을 직접 제어하는 게 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라 한다.

## 프레임워크 vs 라이브러리

- 개발자가 작성한 코드를 제어하고, 대신 실행하면 프레임워크다.(JUnit)
- 개발자가 작성한 코드가 직접 제어의 흐름을 담당한다면 라이브러리다.

## 정적인 클래스 의존 관계

- 클래스 다이어그램
- 클래스가 상속한 import 코드만 보고 의존 관계를 쉽게 판단할 수 있다.
- 즉, 애플리케이션을 실행하지 않아도 분석할 수 있다.
- 하지만 실제 주입되는 interface의 구현체를 알 수 없다.

## 동적인 객체 인스턴스 의존 관계

- 객체 다이어그램
- 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계.

## DI(Dependency Injection 의존 관계 주입)

- 애플리케이션 실행 시점(런타임)에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존 관계가 연결되는 것.
- 객체 인스턴스를 생성하고, 그 참조값을 전달함으로써 연결된다.
- 클라이언트 코드를 변경하지 않고, 클라이언트 호출 대상의 타입 인스턴스를 변경할 수 있다.
- 즉, 정적인 클래스 의존 관계를 변경하지 않고, 동적인 객체 인스턴스 의존 관계를 쉽게 변경할 수 있다.

## 싱글톤 방식 주의점
- 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 떄문에 객체의 상태를 유지(stateful)하게 설계하면 안 된다.
- 무상태(stateless)로 설계
	+ 특정 클라이언트에 의존적인 필드가 있으면 안 된다.
	+ 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안 된다.
	+ 가급적 읽기만 가능해야 한다.(수정X)
	+ 필드 대신 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈은 **항상 무상태**로 설계하자!

## 스프링 빈의 싱글톤
- CGLIB 바이트코드 조작 라이브러리로 AppConfig를 상속받은 임의의 다른 클래스를 만든다.
- 내가 작성한 클래스가 아닌, 임의로 생성된 다른 클래스를 빈으로 등록한다.
- 임의의 클래스가 싱글톤이 보장되도록 해준다.
- @Bean이 붙은 메서드마다 이미 스프링 빈이 컨테이너에 존재하면 스프링 컨테이너에서 찾아 반환하고, 없으면 기존 로직을 호출해서 컨테이너에 등록 및 반환하는 코드가 동적으로 만들어진다.
- @Configuration 없이 @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤 보장은 안 된다.(@Autowired 사용시 해결 가능)